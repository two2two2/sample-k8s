# ローリングアップデートサンプル
## strategy1
| maxSurge | maxUnavailable |
|----------|----------------|
| 25%      | 25%            |

全体の1/4ずつ更新していく

### メリット
* バランスよく設定することでアップデート中のアプリケーションのパフォーマンスを維持しつつとリソース仕様量を節約できる

### デメリット
* アプリケーションのスピンアップ速度によって最適な値を調整する必要がある
  - maxUnavailableが多すぎるとアップデート中のシステムのパフォーマンスが大きく落ちてしまう可能性がある
  - maxSurgeが多すぎると、アップデート中にノードのリソースを大きく消費してしまう
* 最適な値を選択するには、しっかりとした調査が必要になる


## strategy2
| maxSurge | maxUnavailable |
|----------|----------------|
| 100%     | 0              |

新しいPodを一気に立ち上げ、起動完了後に古いPodが削除される

### メリット
* 新しいPodが一気に立ち上がるため、更新終了が早い
* 更新中のパフォーマンスが落とさないようにできる

### デメリット
* replica数が多かったりコンテナのrequestsリソースが多いと、アップデート中にリソースが大きく消費される


## strategy3
| maxSurge | maxUnavailable |
|----------|----------------|
| 1        | 0              |

新しいPodが一つづつ立ち上がっていく

### メリット
* 増えるPodが一つずつのため、リソース使用量を低くすることができる
* 更新中のパフォーマンスが落とさないようにできる

### デメリット
* 更新終了まで時間がかかる


## 総評
更新頻度や更新時の負荷、スピンアップ速度などが明確ではない現状では、とりあえず`strategy3`を適用するのがベターと考える。

リソースの消費量も計算しやすく、また更新時のパフォーマンスが落ちることもないため、まずはこの方式から始めてみて、検証期間中や運用中に更新時間などに課題が出てくるようなら`strategy1`に切り替えていく感じ。  
その頃には、具体的な課題も出ていると思うため現時点でベストな設定値を見つけるよりもだいぶ難易度は下がっているはず。

逆に、`strategy2`は最初に試してみる戦略としてはあまり向いていない。

更新時のリソース割り当てが極端に大きくなるため、クラスタのリソース割り当てが足りない場合にCrashBackoffLoopにハマったりする可能性もあるし、またそのような問題が発生しない様にクラスタサイズを大きくすることで余計な料金が発生してしまう。  
更新時間の最適化を求めた結果、最終的にこの戦略になる可能性もあるが、まだ課題が明確ではないこの時点では取るべきではない。


## その他
どの戦略にも言えることだが、`ローリングアップデート`は古いアプリケーションと新しいアプリケーションが混在する期間が少なからず存在する更新方法のため、更新内容によっては全く向いていない可能性がある。

更新内容が破壊的なもので、絶対に古いアプリケーションと新しいアプリケーションが混在しては行けないようなケースではBlue-Green Deployが必要になるケースもあるため、その点は意識しておくと良いかもしれない。
も試して見ても良いかもしれない。

k8sでBlue-Greenデプロイをやる方法として代表的な手法は

* Podのラベルにバージョン情報を含めておき、ServiceのSelectorにバージョン付きで指定する
* Ingressのtarget Serviceを新しいバージョンのサービスに向くようにターゲットを変更する

の二パターンがある。
